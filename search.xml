<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[三月份的尾巴是四月的计划]]></title>
    <url>%2F2018%2F03%2F31%2F%E4%B8%89%E6%9C%88%E4%BB%BD%E7%9A%84%E5%B0%BE%E5%B7%B4%E6%98%AF%E5%9B%9B%E6%9C%88%E7%9A%84%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[离自己在新 “year” 里创建这个博客眨眼就又跨了个“年”。开学伊始，便是准备找实习，连学习和生活都被打乱了。现在又基本安定下来，所以就阶段性规划一下。 Time Activity PlanB Or Pretense 7：00 - 7：30 该起床了 没有B计划，不能睡懒觉 before 8：00 Reading English 附加 breakfast，为了祖国的花朵 上午时光 R 与 数据科学 不可预知的外事/(ㄒoㄒ)/~~ 12：30左右 吃饭和睡觉一样舒服 没可能不吃饭，我要增肥 午后时光(Af14：00) 两点之前要睡觉，两点之后做项目 谁都有可能遇个急事 晚饭后 看个电影？看篇文章？写个 review 接续下午的事业也不错 22：00 前 要运动，跑几圈就好了 没跑就回去多学习 22：00 -23：00 复习复习，洗洗睡了 要记住，早睡不是关键，早起才是目的 写完了，回头一瞅，这是什么蛇皮计划，好像连一点明确的目标都没有。但是写着的过程中，想着我的“小目标”是真的小啊 (￣ ‘i ￣;)，原谅我脸皮薄吧。 既然又写起来了，那么就写多几句话。 春天到了，又是那俩个词“思春”和“悲秋”…… 不说了，愿 zkx 找到好实习吧，xzz 稳了我信他。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>planning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以太坊私有链及开发（二）]]></title>
    <url>%2F2018%2F01%2F20%2F%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E6%9C%89%E9%93%BE%E5%8F%8A%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文将在前文基础上，进一步对在 docker 容器上部署以太坊私有链节点展开实践。在文章最后提出了三点疑问。 geth相关前提准备知识通过geth命令就可以启动 peer-to-peer 节点，默认启动节点会接入以太坊生产环境网络（网络id：1），此处将记录附带参数从而将本地或者远端已存在的以太坊私有链节点开启。 一般常用 ethereum options：--datadir {path}: 指定 geth 在启动节点时 databases 和 keystore 的文件夹地址 path--networkid {num}: 指定私有链的网络 id，注意区别于主网络与测试网络 num 涉及到到的 command：init gensis.json：初始化节点 创世区块配置信息记录在 json 文件中attach {ipc path}：通过ipc文件连接到节点的 JS 控制台 docker部署构建 geth 自定义镜像 新建文件夹并进入，创建以太坊节点创世区块配置文件 vi gensis.json 1234567891011121314151617&#123; "config": &#123; "chainId": 100863, "homesteadBlock": 0, "eip155Block": 0, "eip158Block": 0 &#125;, "alloc" : &#123;&#125;, "coinbase" : "0x0000000000000000000000000000000000000000", "difficulty" : "0x20000", "extraData" : "", "gasLimit" : "0xffffffff", "nonce" : "0x123456789a000042", "mixhash" : "0x0000000000000000000000000000000000000000000000000000000000000000", "parentHash" : "0x0000000000000000000000000000000000000000000000000000000000000000", "timestamp" : "0x00"&#125; 自定义 Dockerfile 文件： 123456789101112131415161718# pull base imageFROM ethereum/client-go# claim authorMAINTAINER believening# make ethereum_node directory as the database directoryWORKDIR /ethereum_node# add genesis.jsonADD genesis.json /ethereum_node# initial the node by genesis.jsonRUN geth --datadir /ethereum_node init /ethereum_node/genesis.json# private expose: Network listening 30303, Rpc listening 8545EXPOSE 30303EXPOSE 8545 ADD 会以 Dockerfile 所在文件夹为初始路径 构建自定义镜像 sudo docker build -t geth/docker:test -f Dockerfile . ： -t : Name and optionally a tag in the ‘name:tag’ format -f : Name of the Dockerfile (Default is ‘PATH/Dockerfile’) 启动 docker 上的 ethereum 节点 docker run：利用镜像启动容器，例如：sudo docker run -it --name docker_node_x -p 30311:30303 geth/docker:test geth --datadir /ethereum_node --networkid 100863: 1、-it 在终端可以进行交互； 2、-p 将主机的端口绑定给容器提供服务的端口 docker restart CONTAINER [CONTAINER ...] : 重新启动容器 CONTAINER， 可启动多个 docker exec [OPTIONS] CONTAINER COMMAND [ARG...] ：在指定容器内指定指定命令可以执行 sudo docker exec -it CONTAINER geth --datadir /ethereum_node attach /ethereum_node/geth.ipc 连接到部署在容器的节点的js控制台 测试发现，容器部署节点时，添加引导节点的 enode 地址并不能将节点相连。 容器内节点使用 admin.addPeer 函数添加节点时不成功，使用的 enode 地址为转换到主机的 ip 及端口。 容器间的交流还需要作讨论，也就是说容器的网络配置还需要学习。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以太坊私有链及开发（一）]]></title>
    <url>%2F2018%2F01%2F18%2F%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E6%9C%89%E9%93%BE%E5%8F%8A%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文将在对以太坊及智能合约进行简单介绍后，对于在本地环境下部署以太坊私有链进行了实践操作，在文章的后半部分则对在 docker 容器中部署以太坊节点做了简单的探索。 基于以太坊的私有链本地部署以太坊和智能合约以太坊是一个开源的有智能合约功能的公共区块链平台，通过其专用加密货币以太币提供去中心化的虚拟机（EVM）来处理点对点合约。正是由于以太坊对智能合约的支持，使得它成为了区块链技术商业化应用落地的一种解决方案。以比特币为代表的区块链初代应用仅仅提供了货币及支付手段的去中心化，智能合约则结束了区块链只被用于交易货币的限制。以太坊的基础单元是账户，这些账户的状态及其状态转移被记录在以太坊区块链上，这种记录有着区块链天生的分布式及不可篡改的特性。被区块链记录的账户分为两类： 外部账户，由私人密码控制。 合约账户，由合约编码控制，通过外部账户激活。 外部账户一般由人类通过控制手中的私钥来掌握。而合约账户则是由内部编码管控。如果他们是被人类用户”控制”的，那也是因为程序设定它们被具有特定地址的外部账户控制，进而被持有私钥控制外部账户的人控制着。”智能合约”这个指的就是在合约账户中编码，这些编码由外部账户持有人编写，在达成交易共识后，随着交易发送并部署到合约账户中开始执行程序。需要注意的是，程序一旦被确认开始执行，外部账户就不能干预了，并且由于编码程序的出现，也就意味着更多功能设计的可能，这也是智能合约能够使区块链技术商业的落地的关键原因之一。 以太坊公网及测试网络以太坊公网—-也就是其生产环境网络—-能够产生真正有价值的以太币。下图是以太坊公网的状态统计(截至2018年1月18日22时30分时)： 以太坊公网是全球化的，部署在公网上的智能合约全世界任何应用都可以调用，合约的的代码，执行以及区块链上区块的调用都清晰可查。由于任何合约的执行都会消耗以太币，且全球化的节点部署，区块生产速度相对较慢，这种情况对于开发调试来讲无论是经济还是时间上都不合适。此外，具体到部分的商业应用场景下，节点并不需要全球部署，在组织或者服务对象内部分布式的部署多台服务器就可以满足业务需要。鉴于此，有别于公网的其他网络环境的提供必不可少。 以太坊官方提供有公开的测试网络用于用户的开发、调试和测试，在测试网络中以太币的挖矿难度很低通过挖矿可以轻松获取，也有需要通过申请就可以获取以太币的网络。这些网络中以太币获取成本可以忽略不计，却同样具备全球部署的特点，受攻击难度高，鲁棒性强，对于针对全球服务的应用来说，是开发、调试和测试的优秀环境。目前，公开可用的测试网络有 Ropsten、Kovan 和 Rinkeby，其中 Rinkeby 是最当下最常用的测试网络，网络id为6，以太币通过github帐号申请就可以获取。 由于，测试是官方提供的，因此使用测试网络对于以太坊技术的底层实现、Geth的各种参数接口、整个以太坊的技术真实性能的理解就会弱很多。所以从开发的角度来说，一个更好的选择是自己创建私有链，可以从技术的底层去深入理解以太坊。 本地以太坊私有链的创建本文将利用Geth实现以太坊私有链的部署。Geth 又名 Go Ethereum，是以太坊协议的三种实现之一，由 Go 语言开发，完全开源的项目。Geth 可以被安装在很多操作系统上，包括Windows、Linux、MacOS、Android 或者 IOS 系统。Geth 的安装参照官网即可，以下主要介绍本地私有链的创建。 准备创始区块并创建第一个私有链节点 为本地私有链建立一个根目录文件夹以便于查看和管理：mkdir /home/believening/localPrivateChain 进入建立的私有链根目录，创建私有链创始区块的配置文件 genesis.json 及第一个节点的根目录 node_one: 123cd /home/believening/localPrivateChainmkdir node_onevi genesis.json 编写创世区块配置文件 genesis.json ： 1234567891011121314151617&#123; "config": &#123; "chainId": 100863, "homesteadBlock": 0, "eip155Block": 0, "eip158Block": 0 &#125;, "alloc" : &#123;&#125;, "coinbase" : "0x0000000000000000000000000000000000000000", "difficulty" : "0x20000", "extraData" : "", "gasLimit" : "0xffffffff", "nonce" : "0x123456789a000042", "mixhash" : "0x0000000000000000000000000000000000000000000000000000000000000000", "parentHash" : "0x0000000000000000000000000000000000000000000000000000000000000000", "timestamp" : "0x00"&#125; genesis.json 文件中重要参数的说明及需要注意的地方如下： chainId : 用于指的是以太坊网络的 id（以太坊公网的 id = 1），该值应设置为区别于其他网络的 id，确保私有。 alloc : 用于定义区块链中预先设定的外部账户，可以为空，节点创建好以后再建立外部账户就可以。 difficulty : 当前区块难度，为了便于挖矿，难度可以设置较小。 gasLimit : 设置为最大，这样区块中的一个节点可以完成的工作量能够处理每个交易。 nonce : 用于挖矿的随机数，将其设置的特别，有助于网络不被外部节点发现。 parentHash : 上一个区块的hash值，由于是创世区块，所以设置为0。 初始化第一个区块链节点并启动 在私有链根目录下执行如下命令geth --datadir node_one init genesis.json后私有链的第一个节点就被初始化建立起来。其中--datadir node_one用于指明节点数据存放的地址，运行结果如下: 其目录结构如下： 值得注意的是，所有需要希望连接到该私有链的区块链节点都必须经过该 genesis,json 配置文件初始化 在私有链根目录执行如下命令geth --datadir node_one --networkid 100863 console进入该区块链节点的控制台： JS控制台下的简单操作 查看账户、创建账户 第一次使用eth.accounts命令可以看到该节点原本并没有账户的，使用personal.newAccount()命令创建账户后，返回的是账户名，函数的参数是所创建账户的密码。我们为该节点创建两个外部账户。 挖矿及余额查询 使用eth.getBalance()查询指定账户余额，通过miner.start() 和 miner.stop()来开启和停止挖矿。eth.coinbase返回当前节点的矿工，默认为第一个外部账户，挖矿奖励的以太币会记入矿工账户，于是看到账户 1 余额增加，而账户 2 余额依然为 0 。eth.blockNumber返回当前节点（或链）中的区块数目，挖矿会使的区块被创造。 节点内账户交易 由于以太坊的保护机制，外部账户个一段时间会被自动上锁，发起交易时需要先将发起账户解锁personal.unlockAccount()，该函数要求输入外部账户的密码。通过eth.sendTransaction()函数发起交易，上图中交易表示从 acc1 账户转账 5 以太币到 acc2 账户，返回交易hash。通过查看 txpool 状态 txpool.status，表明交易已经被提交但是并没有被处理（penging值为1），这一点通过账户余额同样被验证。 当新的区块被生产出来，交易会在新区块中被处理，查看余额，显示交易完成。 可以分别利用eth.getTransation()传入交易 hash 值和eth.getBlock()传入记录交易的区块的编号来查询交易。 创建其他节点并构建网络 创建其他节点并新建账户 该过程同上以小节创建第一个节点一样 创建好第二个节点后私有链根目录的结构如下： 构建网络 以太坊私有链构建网络可以通过两种不同的方式 在相同的networkid参数配置下启动网络，通过控制台函数实现节点间点对点的连接，进而连通网络。 设置虚拟的网络引导节点，并通过启动参数配置给每一个私有链的真实节点，从而实现网络连通。 首先介绍第一种方式：在一个终端里启动第一个节点：geth --datadir node_one --networkid 100863 --port 30301 --nodiscover console 2&gt;&gt;node_one/geth.log在另一个终端里用类似命令启动第二个节点：geth --datadir node_two --networkid 100863 --port 30303 --nodiscover console 2&gt;&gt;node_two/geth.log命令中--port指定了 .ipc 文件将要用到的端口，也就是使用 web3.js 库连接数据库的方式。--nodiscover告诉geth最初不要寻找其他节点，在私有网链中，既不希望节点在没有指定的情况下尝试连接到其它节点，也不希望节点在没有主动告诉其他节点的情况下被发现。 通过admin.peers、net.peerCount可以查看区块链中节点的概况，在连接两个节点前后分别查看前述两个参数及节点区块数，可以验证两个节点的确被连通。通过admin.addPeer()函数，将需要接入结点的 enode 地址传入后，就可以实现点对点的节点连接。 注意的是，要将 enode 地址中[::]替换为节点所在主机的 ip 地址。 其次介绍第二种方式：依次终端中键入bootnode --genkey=boot.key、bootnode --nodekey=boot.key命令，以设置启动的引导节点。 记录下引导节点的 enode 地址后，分别在各自的终端启动节点节点一：geth --datadir node_one --networkid 100863 --port 30303 --bootnodes enode://30d32e7b7e395f8eb8d9bc462e178420393af8e646975a1c521739ba03924390cf6362be81bb0034b4baf08d02ce5ef16adbe5e7a384fe3a80c482d8ce415e93@10.0.2.15:30301 console 2&gt;&gt;node_one/geth.log节点二：geth --datadir node_two --networkid 100863 --port 30305 --bootnodes enode://30d32e7b7e395f8eb8d9bc462e178420393af8e646975a1c521739ba03924390cf6362be81bb0034b4baf08d02ce5ef16adbe5e7a384fe3a80c482d8ce415e93@10.0.2.15:30301 console 2&gt;&gt;node_two/geth.log此时，启动参数中删除了--nodiscover，增加了--bootnodes，在节点启动时就建立好连系，这种方式是相对更加被提倡的方式，特别是当建好的私有链时刻处于运行中时。 网络中节点间交易 前面实践了单个节点内账户的交易，此处操作下节点间账户交易，其过程同单个节点内外部账户交易并无不同 将以太坊私有链节点部署在Docker中Docker概况Docker 是一个基于 Go 语言的开源应用容器引擎。使用Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 目前容器技术已经广泛地应用在商业场进中 Web 应用的自动化打包和发布。 自动化测试和持续集成、发布。 在服务型环境中部署和调整数据库或其他的后台应用。 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。 Docker 作为容器业内的第一梯队，具有以下优点： 简化程序：Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的任务，在 Docker 容器的处理下，只需要数秒就能完成。 打包部署：DDocker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用，又比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。 节省开支：一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。 利用 Docker 部署以太坊节点Docker 的安装参照官网，以下主要介绍在 Docker 上部署私有链节点。 下载 geth 的 Docker 镜像 sudo docker pull ethereum/client-go ： 在私有链根目录下创建 docker_node 文件夹，并将 genesis.json 复制到其中。然后编写 Dockerfile 文件，构建自定义镜像 geth/docker,sudo docker build -t geth/docker .: 12345678910111213141516171819#Pull base imageFROM ethereum/client-goMAINTAINER believening# make docker_node directoryRUN mkdir docker_node# add genesis.jsonADD genesis.json docker_node# initial genesis.jsonRUN geth --datadir docker_node init docker_node/genesis.json# private exposeEXPOSE 30307# volumeVOLUME "/home/believening/localPrivateChain/docker_node" 构建好进行后便可以在容器中部署启动以太坊节点了，sudo docker run -it --name ethereumDocker geth/docker --datadir docker_node --networkid 100863 --bootnodes enode://30d32e7b7e395f8eb8d9bc462e178420393af8e646975a1c521739ba03924390cf6362be81bb0034b4baf08d02ce5ef16adbe5e7a384fe3a80c482d8ce415e93@10.0.2.15:30301 console：]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>docker</tag>
      </tags>
  </entry>
</search>
